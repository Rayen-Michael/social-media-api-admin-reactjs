{"version":3,"file":"static/js/81.11bd7bc4.chunk.js","mappings":"oMAgCA,UA5BqB,WACjB,IAAMA,GAAWC,EAAAA,EAAAA,MASjB,OAPAC,EAAAA,EAAAA,YAAU,WAGN,OAFAC,SAASC,MAAQ,YAEV,WAAQ,CAEnB,GAAG,KAGC,iBAAKC,UAAU,YAAYC,MAAO,CAC9BC,MAAO,OACPC,OAAQ,SACV,WACE,8CACA,SAAC,IAAM,CACHC,QAAQ,OACRC,MAAM,YACNC,GAAI,CAAEC,UAAW,OACjBC,QAAS,kBAAMb,EAAS,IAAI,EAAC,0BAM7C,C,uCC7BA,IAAec,EAAgB,C,sCCA/B,IAAeC,EAAiB,C,uCCA1BC,EAAsC,qBAAXC,OAAyBC,EAAAA,gBAAwBA,EAAAA,UAClF,K,kFCIe,SAASJ,EAAiBK,GACvC,IAAMC,EAAMF,EAAAA,OAAaC,GAIzB,OAHAH,EAAAA,EAAAA,IAAkB,WAChBI,EAAIC,QAAUF,CAChB,IACOD,EAAAA,aAAkB,kBAErBE,EAAIC,QAAO,uBAAU,GAAE,GAC7B,C,4DCVIC,E,WAFAC,GAAmB,EACnBC,GAA0B,EAExBC,EAAsB,CAC1BC,MAAM,EACNC,QAAQ,EACRC,KAAK,EACLC,KAAK,EACLC,OAAO,EACPC,UAAU,EACVC,QAAQ,EACRC,MAAM,EACNC,OAAO,EACPC,MAAM,EACNC,MAAM,EACNC,UAAU,EACV,kBAAkB,GAuCpB,SAASC,EAAcC,GACjBA,EAAMC,SAAWD,EAAME,QAAUF,EAAMG,UAI3CnB,GAAmB,EACrB,CAUA,SAASoB,IACPpB,GAAmB,CACrB,CAEA,SAASqB,IACsB,WAAzBC,KAAKC,iBAKHtB,IACFD,GAAmB,EAGzB,CAkBA,SAASwB,EAAeR,GACtB,IACES,EACET,EADFS,OAGF,IACE,OAAOA,EAAOC,QAAQ,iBAItB,CAHA,MAAOC,GAGP,CAKF,OAAO3B,GA5FT,SAAuC4B,GACrC,IACEC,EAEED,EAFFC,KACAC,EACEF,EADFE,QAGF,QAAgB,UAAZA,IAAuB5B,EAAoB2B,IAAUD,EAAKG,WAI9C,aAAZD,IAA2BF,EAAKG,YAIhCH,EAAKI,iBAKX,CAyE6BC,CAA8BR,EAC3D,CAEe,SAASjC,IACtB,IAAMK,EAAMF,EAAAA,aAAkB,SAAAiC,GAnChC,IAAiBM,EAoCD,MAARN,KApCSM,EAqCHN,EAAKO,eApCbC,iBAAiB,UAAWrB,GAAe,GAC/CmB,EAAIE,iBAAiB,YAAahB,GAAmB,GACrDc,EAAIE,iBAAiB,cAAehB,GAAmB,GACvDc,EAAIE,iBAAiB,aAAchB,GAAmB,GACtDc,EAAIE,iBAAiB,mBAAoBf,GAAwB,GAkCjE,GAAG,IACGgB,EAAoB1C,EAAAA,QAAa,GAyCvC,MAAO,CACL0C,kBAAAA,EACAC,QAXF,SAA4BtB,GAC1B,QAAIQ,EAAeR,KACjBqB,EAAkBvC,SAAU,GACrB,EAIX,EAKEyC,OAvCF,WAME,QAAIF,EAAkBvC,UAKpBG,GAA0B,EAC1BP,OAAO8C,aAAazC,GACpBA,EAAiCL,OAAO+C,YAAW,WACjDxC,GAA0B,CAC5B,GAAG,KACHoC,EAAkBvC,SAAU,GACrB,EAIX,EAmBED,IAAAA,EAEJ,C","sources":["pages/not-found/Index.jsx","../node_modules/.pnpm/@mui+material@5.10.13_5rzy53przelm5jchjmb5vr6dxy/node_modules/@mui/material/esm/utils/useEventCallback.js","../node_modules/.pnpm/@mui+material@5.10.13_5rzy53przelm5jchjmb5vr6dxy/node_modules/@mui/material/esm/utils/useIsFocusVisible.js","../node_modules/.pnpm/@mui+utils@5.10.9_react@18.2.0/node_modules/@mui/utils/esm/useEnhancedEffect.js","../node_modules/.pnpm/@mui+utils@5.10.9_react@18.2.0/node_modules/@mui/utils/esm/useEventCallback.js","../node_modules/.pnpm/@mui+utils@5.10.9_react@18.2.0/node_modules/@mui/utils/esm/useIsFocusVisible.js"],"sourcesContent":["import { useEffect } from 'react';\r\nimport Button from '@mui/material/Button';\r\nimport { useNavigate } from 'react-router-dom';\r\n\r\nconst NotFoundPage = () => {\r\n    const navigate = useNavigate();\r\n\r\n    useEffect(() => {\r\n        document.title = \"Not Found\";\r\n\r\n        return () => { }\r\n\r\n    }, []);\r\n\r\n    return (\r\n        <div className=\"app__flex\" style={{\r\n            width: \"100%\",\r\n            height: \"100vh\",\r\n        }}>\r\n            <div>Page Not Found!</div>\r\n            <Button\r\n                variant=\"text\"\r\n                color='secondary'\r\n                sx={{ marginTop: \"4px\" }}\r\n                onClick={() => navigate(\"/\")}\r\n            >\r\n                Go to Home\r\n            </Button>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default NotFoundPage;","import { unstable_useEventCallback as useEventCallback } from '@mui/utils';\nexport default useEventCallback;","import { unstable_useIsFocusVisible as useIsFocusVisible } from '@mui/utils';\nexport default useIsFocusVisible;","import * as React from 'react';\nconst useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nexport default useEnhancedEffect;","import * as React from 'react';\nimport useEnhancedEffect from './useEnhancedEffect';\n/**\n * https://github.com/facebook/react/issues/14099#issuecomment-440013892\n */\n\nexport default function useEventCallback(fn) {\n  const ref = React.useRef(fn);\n  useEnhancedEffect(() => {\n    ref.current = fn;\n  });\n  return React.useCallback((...args) => // @ts-expect-error hide `this`\n  // tslint:disable-next-line:ban-comma-operator\n  (0, ref.current)(...args), []);\n}","// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nimport * as React from 'react';\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\nlet hadFocusVisibleRecentlyTimeout;\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @returns {boolean}\n */\n\nfunction focusTriggersKeyboardModality(node) {\n  const {\n    type,\n    tagName\n  } = node;\n\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n\n  if (node.isContentEditable) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n\n\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n\n  hadKeyboardEvent = true;\n}\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\n\n\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\n\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\n\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nexport function teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nfunction isFocusVisible(event) {\n  const {\n    target\n  } = event;\n\n  try {\n    return target.matches(':focus-visible');\n  } catch (error) {// Browsers not implementing :focus-visible will throw a SyntaxError.\n    // We use our own heuristic for those browsers.\n    // Rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  } // No need for validFocusTarget check. The user does that by attaching it to\n  // focusable events only.\n\n\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\n\nexport default function useIsFocusVisible() {\n  const ref = React.useCallback(node => {\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n  const isFocusVisibleRef = React.useRef(false);\n  /**\n   * Should be called if a blur event is fired\n   */\n\n  function handleBlurVisible() {\n    // checking against potential state variable does not suffice if we focus and blur synchronously.\n    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.\n    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.\n    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751\n    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).\n    if (isFocusVisibleRef.current) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {\n        hadFocusVisibleRecently = false;\n      }, 100);\n      isFocusVisibleRef.current = false;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Should be called if a blur event is fired\n   */\n\n\n  function handleFocusVisible(event) {\n    if (isFocusVisible(event)) {\n      isFocusVisibleRef.current = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  return {\n    isFocusVisibleRef,\n    onFocus: handleFocusVisible,\n    onBlur: handleBlurVisible,\n    ref\n  };\n}"],"names":["navigate","useNavigate","useEffect","document","title","className","style","width","height","variant","color","sx","marginTop","onClick","useEventCallback","useIsFocusVisible","useEnhancedEffect","window","React","fn","ref","current","hadFocusVisibleRecentlyTimeout","hadKeyboardEvent","hadFocusVisibleRecently","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","handleKeyDown","event","metaKey","altKey","ctrlKey","handlePointerDown","handleVisibilityChange","this","visibilityState","isFocusVisible","target","matches","error","node","type","tagName","readOnly","isContentEditable","focusTriggersKeyboardModality","doc","ownerDocument","addEventListener","isFocusVisibleRef","onFocus","onBlur","clearTimeout","setTimeout"],"sourceRoot":""}